create table public."Orderitems" (
  id bigint generated by default as identity not null,
  order_id bigint null,
  ticket_id bigint null,
  quantity bigint null,
  sub_price text null,
  userid text null,
  status text null default 'confirmed'::text,
  used_premium_discount boolean null,
  constraint Orderitems_pkey primary key (id),
  constraint Orderitems_order_id_fkey foreign KEY (order_id) references orders (id),
  constraint Orderitems_ticket_id_fkey foreign KEY (ticket_id) references tickets (id),
  constraint Orderitems_userid_fkey foreign KEY (userid) references users (user_id)
) TABLESPACE pg_default;

create table public.connections (
  connection_id serial not null,
  user_id1 text null,
  user_id2 text null,
  status character varying(255) null,
  constraint connections_pkey primary key (connection_id),
  constraint connections_user_id1_fkey foreign KEY (user_id1) references users (user_id),
  constraint connections_user_id2_fkey foreign KEY (user_id2) references users (user_id),
  constraint connections_status_check check (
    (
      (status)::text = any (
        array[
          ('requested'::character varying)::text,
          ('accepted'::character varying)::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create table public.duos (
  id uuid not null default gen_random_uuid (),
  requester_id text not null,
  partner_id text not null,
  status character varying(20) not null default 'pending'::character varying,
  created_at timestamp without time zone null default now(),
  constraint duos_pkey primary key (id),
  constraint unique_duo_pair unique (requester_id, partner_id),
  constraint fk_partner foreign KEY (partner_id) references users (user_id) on delete CASCADE,
  constraint fk_requester foreign KEY (requester_id) references users (user_id) on delete CASCADE,
  constraint no_self_duo check ((requester_id <> partner_id))
) TABLESPACE pg_default;

create table public.groups (
  group_id serial not null,
  name text null,
  location text null,
  joined_members integer null,
  description text null,
  exclusive boolean null,
  profile_image text null,
  interests text[] null,
  images text[] null,
  top_events boolean null,
  group_type text null,
  category text null,
  city text null,
  startdatetime timestamp with time zone null,
  enddatetime timestamp with time zone null,
  event_status text null,
  hidden boolean null,
  iftickets boolean null,
  userid text null,
  videos text null,
  premiumtype text null,
  constraint groups_pkey primary key (group_id),
  constraint groups_userid_fkey foreign KEY (userid) references users (user_id)
) TABLESPACE pg_default;

create index IF not exists idx_groups_location on public.groups using btree (location) TABLESPACE pg_default;

create table public.orders (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  user_id text null,
  total_price text null,
  status public.orderstatustype null default 'confirmed'::orderstatustype,
  paymentid text null,
  constraint orders_pkey primary key (id),
  constraint orders_user_id_fkey foreign KEY (user_id) references users (user_id)
) TABLESPACE pg_default;

create trigger order_cancellation
after
update OF status on orders for EACH row when (
  old.status = 'confirmed'::orderstatustype
  and new.status = 'cancelled'::orderstatustype
)
execute FUNCTION handle_cancellation ();

create table public.subscription (
  id uuid not null default gen_random_uuid (),
  user_id text not null,
  venue_id bigint not null,
  playing_date_and_time jsonb not null,
  type text not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint subscription_pkey primary key (id),
  constraint subscription_user_id_fkey foreign KEY (user_id) references users (user_id) on delete CASCADE,
  constraint subscription_venue_id_fkey foreign KEY (venue_id) references venues (id) on delete CASCADE
) TABLESPACE pg_default;

create table public.tags (
  id uuid not null default gen_random_uuid (),
  user_id text not null,
  ticket_id bigint not null,
  tag text not null,
  constraint tags_pkey primary key (id),
  constraint tags_ticket_id_fkey foreign KEY (ticket_id) references tickets (id) on delete CASCADE,
  constraint tags_user_id_fkey foreign KEY (user_id) references users (user_id) on delete CASCADE
) TABLESPACE pg_default;

create table public.tickets (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  group_id integer null,
  type text null,
  title text null,
  description text null,
  capacity bigint null,
  startdatetime timestamp with time zone null,
  enddatetime timestamp with time zone null,
  ticketstatus text null,
  price text null,
  priceincludinggst boolean null,
  ticketpergroup text null,
  sku text null,
  bookedtickets bigint null default '0'::bigint,
  location text null,
  wooid bigint null,
  venueid bigint null,
  images text[] null,
  constraint tickets_pkey primary key (id),
  constraint tickets_group_id_fkey foreign KEY (group_id) references groups (group_id),
  constraint tickets_venueid_fkey foreign KEY (venueid) references venues (id)
) TABLESPACE pg_default;

create table public.users (
  age text null,
  images text[] null,
  location text null,
  faith text null,
  drink text null,
  smoke text null,
  college character varying(255) null,
  work character varying(255) null,
  interests text[] null,
  zodiac character varying(255) null,
  political_leaning character varying(255) null,
  hometown character varying(255) null,
  mother_tongue text[] null,
  recommended_users text[] null,
  last_updated timestamp without time zone null,
  liked_users text[] null,
  first_name character varying(255) null,
  email character varying(255) null,
  birthday date null,
  gender text null,
  looking_for text null,
  height text null,
  workout_status character varying(255) null,
  pets character varying(255) null,
  bio text null,
  is_premium boolean null default false,
  profile_completion bigint null,
  user_id text not null,
  graduation_year character varying null,
  company character varying null,
  recommendationtimedays smallint null,
  openfordating boolean null default true,
  premiumtype text null,
  premiumvalidtill timestamp with time zone null,
  secrets text[] null,
  created timestamp with time zone null default now(),
  usersetlevel text null,
  adminsetlevel text null,
  constraint users_pkey primary key (user_id),
  constraint users_uid_key unique (user_id),
  constraint users_email_key unique (email),
  constraint users_workout_status_check check (
    (
      (workout_status)::text = any (
        array[
          ('regularly'::character varying)::text,
          ('sometimes'::character varying)::text,
          ('not active'::character varying)::text
        ]
      )
    )
  ),
  constraint users_pets_check check (
    (
      (pets)::text = any (
        array[
          ('want'::character varying)::text,
          ('dogs'::character varying)::text,
          ('want cats'::character varying)::text,
          ('no thanks'::character varying)::text
        ]
      )
    )
  ),
  constraint users_gender_check check (
    (
      gender = any (
        array[
          ('male'::character varying)::text,
          ('female'::character varying)::text
        ]
      )
    )
  ),
  constraint users_looking_for_check check (
    (
      looking_for = any (
        array[
          ('relationship'::character varying)::text,
          ('casual'::character varying)::text,
          ('dont know yet'::character varying)::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_users_interests on public.users using btree (interests) TABLESPACE pg_default;

create index IF not exists idx_users_age on public.users using btree (age) TABLESPACE pg_default;

create index IF not exists idx_users_location on public.users using btree (location) TABLESPACE pg_default;

create trigger update_profile_completion_trigger BEFORE INSERT
or
update on users for EACH row
execute FUNCTION update_profile_completion ();

create table public.venues (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  venue_name text null,
  images text[] null,
  maps_link text null,
  description text null,
  location text null,
  constraint venues_pkey primary key (id)
) TABLESPACE pg_default;

CREATE TABLE squads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    squad_name VARCHAR(255) NOT NULL,
    squad_members JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE squads
ADD CONSTRAINT check_squad_members_count
CHECK (jsonb_array_length(squad_members) >= 2 AND jsonb_array_length(squad_members) <= 8);

CREATE OR REPLACE FUNCTION get_recent_game_members()
RETURNS SETOF JSONB
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT jsonb_array_elements(g.members)
  FROM games g
  ORDER BY g.created_at DESC
  LIMIT 5;
END;
$$;

CREATE OR REPLACE FUNCTION get_ticket_buddies_by_user_id(p_user_id TEXT)
RETURNS SETOF JSONB
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    jsonb_build_object(
      'member_id', u.user_id,
      'member_name', u.first_name
    )
  FROM
    public.orderitems oi
  JOIN
    public.users u ON oi.userid = u.user_id
  WHERE
    oi.ticket_id IN (
      SELECT DISTINCT ticket_id
      FROM public.orderitems
      WHERE userid = p_user_id
    )
    AND oi.userid <> p_user_id;
END;
$$;

--HERE ARE THE RPC FUNCTIONS WHICH ARE ALREADY IN MY DATABASE
create or replace function get_user_with_tags(
  p_user_id text
)
returns jsonb
language plpgsql
as $$
declare 
  profile_data jsonb;
  tag_data jsonb;
begin
  -- Get selected user profile fields only
  select jsonb_build_object(
           'user_id', u.user_id,
           'first_name', u.first_name,
           'email', u.email,
           'usersetlevel', u.usersetlevel,
           'adminsetlevel', u.adminsetlevel,
           'location', u.location
         )
  into profile_data
  from public.users u
  where u.user_id = p_user_id;

  -- Get distinct tags with ticket members and connection status
  select coalesce(
           jsonb_agg(
             jsonb_build_object(
               'tag', distinct_tags.tag,
               'venue', distinct_tags.title,
               'ticket_members', (
                 select jsonb_agg(
                          jsonb_build_object(
                            'id', u.user_id,
                            'name', u.first_name,
                            'connection', exists (
                              select 1
                              from public.connections c
                              where c.status = 'accepted'
                                and (
                                  (c.user_id1 = p_user_id and c.user_id2 = u.user_id)
                                  or
                                  (c.user_id2 = p_user_id and c.user_id1 = u.user_id)
                                )
                            )
                          )
                        )
                 from public."Orderitems" oi
                 left join public.users u on oi.userid = u.user_id
                 where oi.ticket_id = distinct_tags.ticket_id
               )
             )
           ), '[]'::jsonb
         )
  into tag_data
  from (
    select distinct on (tg.tag, tg.ticket_id)
           tg.tag,
           tg.ticket_id,
           tk.title
    from public.tags tg
    left join public.tickets tk on tg.ticket_id = tk.id
    where tg.user_id = p_user_id
      and exists (
        select 1
        from public."Orderitems" oi
        where oi.ticket_id = tg.ticket_id
          and oi.userid = p_user_id
      )
    order by tg.tag, tg.ticket_id, tg.id
  ) as distinct_tags;

  -- Final result: { profile: ..., tags: [...] }
  return jsonb_build_object(
           'profile', profile_data,
           'tags', tag_data
         );
end;
$$;


--FUNCTION FOR GETTING USER GAMES 
CREATE OR REPLACE FUNCTION get_user_games(
  user_id_param text,
  page_param integer DEFAULT 1,
  limit_param integer DEFAULT 10
)
RETURNS json
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN (
    SELECT json_agg(
      json_build_object(
        'id', t.id,
        'title', t.title,
        'created_at', t.created_at,
        'members', members_array
      )
    )
    FROM (
      SELECT 
        t.id,
        t.title,
        t.created_at,
        json_agg(
          json_build_object(
            'id', u.user_id,
            'name', u.first_name,
            'connection', CASE 
              WHEN EXISTS (
                SELECT 1 FROM connections c 
                WHERE ((c.user_id1 = user_id_param AND c.user_id2 = u.user_id) 
                   OR (c.user_id2 = user_id_param AND c.user_id1 = u.user_id))
                AND c.status = 'accepted'
              ) THEN true
              ELSE false
            END
          )
        ) as members_array
      FROM tickets t
      JOIN "Orderitems" oi ON t.id = oi.ticket_id
      JOIN orders o ON oi.order_id = o.id
      JOIN users u ON oi.userid = u.user_id
      WHERE t.id IN (
        SELECT DISTINCT ticket_id 
        FROM "Orderitems" 
        WHERE userid = user_id_param AND status = 'confirmed'
      )
      AND oi.status = 'confirmed'
      GROUP BY t.id, t.title, t.created_at
      ORDER BY t.created_at DESC
      LIMIT limit_param
      OFFSET (page_param - 1) * limit_param
    ) t
  );
END;
$$;

--FOR HANDLING DUO REQUESTS
create or replace function handle_duo_requests(
  p_duo_id uuid,
  p_user_id text,
  p_status text
)
returns void
language plpgsql
as $$
declare
  duo_record record;
begin
  -- Validate status
  if p_status not in ('accepted', 'declined') then
    raise exception 'Invalid status: %', p_status;
  end if;

  -- Get the duo request
  select * into duo_record from duos where id = p_duo_id;

  if not found then
    raise exception 'Duo request not found';
  end if;

  -- Ensure the user is part of the duo request
  if p_user_id not in (duo_record.requester_id, duo_record.partner_id) then
    raise exception 'User is not part of this duo request';
  end if;

  -- If accepting, ensure user doesnâ€™t already have a duo
  if p_status = 'accepted' then
    if exists (
      select 1 from duos 
      where status = 'accepted'
        and (requester_id = p_user_id or partner_id = p_user_id)
    ) then
      raise exception 'User already has an accepted duo';
    end if;
  end if;

  -- Update the duo request with the new status
  update duos
set 
  status = p_status,
  partner_id = duo_record.partner_id,  -- force broadcast trigger
  requester_id = duo_record.requester_id
where id = p_duo_id;

  -- If accepted, delete all other pending duos for both users
  if p_status = 'accepted' then
    delete from duos 
    where status = 'pending'
      and id != p_duo_id
      and (
        requester_id in (duo_record.requester_id, duo_record.partner_id)
        or partner_id in (duo_record.requester_id, duo_record.partner_id)
      );
  end if;
end;
$$;

--IT GETS THE PROFILE

create or replace function get_user_with_duos(p_user_id text)
returns jsonb
language plpgsql
as $
declare
  profile_data jsonb := null;
  requester_duos jsonb := '[]'::jsonb;
  partner_duos jsonb := '[]'::jsonb;
  all_duos jsonb := '[]'::jsonb;
  current_duo jsonb := null;
  current_subscription jsonb := null;
begin
  -- Get minimal profile info
  select jsonb_build_object(
    'user_id', u.user_id,
    'first_name', u.first_name,
    'email', u.email,
    'usersetlevel', u.usersetlevel,
    'adminsetlevel', u.adminsetlevel
  )
  into profile_data
  from users u
  where u.user_id = p_user_id;

  if profile_data is null then
    return null;
  end if;

  -- Duos where user is requester
  select jsonb_agg(jsonb_build_object(
    'duo_id', d.id,
    'status', d.status,
    'created_at', d.created_at,
    'is_requester', true,
    'other_user', jsonb_build_object(
      'user_id', u.user_id,
      'first_name', u.first_name,
      'email', u.email,
      'usersetlevel', u.usersetlevel,
      'adminsetlevel', u.adminsetlevel
    )
  ))
  into requester_duos
  from duos d
  join users u on u.user_id = d.partner_id
  where d.requester_id = p_user_id;

  -- Duos where user is partner
  select jsonb_agg(jsonb_build_object(
    'duo_id', d.id,
    'status', d.status,
    'created_at', d.created_at,
    'is_requester', false,
    'other_user', jsonb_build_object(
      'user_id', u.user_id,
      'first_name', u.first_name,
      'email', u.email,
      'usersetlevel', u.usersetlevel,
      'adminsetlevel', u.adminsetlevel
    )
  ))
  into partner_duos
  from duos d
  join users u on u.user_id = d.requester_id
  where d.partner_id = p_user_id;

  -- Merge requester + partner duos
  all_duos := coalesce(requester_duos, '[]'::jsonb) || coalesce(partner_duos, '[]'::jsonb);

  -- Get current duo (accepted status)
  select jsonb_build_object(
    'duo_id', d.id,
    'status', d.status,
    'created_at', d.created_at,
    'is_requester', case when d.requester_id = p_user_id then true else false end,
    'other_user', jsonb_build_object(
      'user_id', u.user_id,
      'first_name', u.first_name,
      'email', u.email,
      'usersetlevel', u.usersetlevel,
      'adminsetlevel', u.adminsetlevel
    )
  )
  into current_duo
  from duos d
  join users u on u.user_id = case 
    when d.requester_id = p_user_id then d.partner_id 
    else d.requester_id 
  end
  where (d.requester_id = p_user_id or d.partner_id = p_user_id)
    and d.status = 'accepted'
  limit 1;

  -- Get current subscription
  select jsonb_build_object(
    'id', s.id,
    'type', s.type,
    'playing_date_and_time', s.playing_date_and_time,
    'created_at', s.created_at,
    'updated_at', s.updated_at,
    'venue_id', s.venue_id
  )
  into current_subscription
  from subscription s
  where s.user_id = p_user_id
  order by s.created_at desc
  limit 1;

  -- Return final object
  return jsonb_build_object(
    'profile', profile_data,
    'duos', all_duos,
    'current_duo', current_duo,
    'current_subscription', current_subscription
  );
end;
$;